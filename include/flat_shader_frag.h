// header file generated by txt2h, 2003-2006 by ScottManDeath
#ifndef  TXT_HEADER_flat_frag_code
#define  TXT_HEADER_flat_frag_code


const char flat_frag_code [] =
"#version 120\n"
"\n"
"varying vec3 vertex_pos;\n"
"\n"
"uniform mat4 MVP;\n"
"\n"
"uniform vec3 COL;\n"
"uniform mat4 M;\n"
"uniform mat4 V;\n"
"\n"
"//Lights\n"
"uniform mat4 FILL;\n"
"uniform mat4 SIDE;\n"
"uniform mat4 BACK;\n"
"\n"
"vec3 flatLight( mat4 light_matrix, vec3 mater_color );\n"
"\n"
"\n"
"void main(){\n"
"  vec3 fill_light = flatLight(FILL, COL);\n"
"  vec3 side_light = flatLight(SIDE, COL);\n"
"  vec3 back_light = flatLight(BACK, COL);\n"
"\n"
"  vec3 mix = vec3(1, 1, 1.5);\n"
"  vec3 color = mix.x * fill_light\n"
"               + mix.y * side_light\n"
"               + mix.z * back_light\n"
"               ;\n"
"  gl_FragColor = vec4(color, 0.3);\n"
"}\n"
"\n"
"\n"
"vec3 flatLight(mat4 light_matrix, vec3 mater_color){\n"
"  vec3  light_posit     = light_matrix[0].xyz;\n"
"  vec3  light_color     = light_matrix[1].xyz;\n"
"  vec3  mix_ratio       = light_matrix[2].xyz;\n"
"  float light_power     = light_matrix[3].x;\n"
"  float lobe_size       = light_matrix[3].y;\n"
"  bool  camera_anchored = bool(light_matrix[3].z);\n"
"\n"
"  float distance = length(light_posit - (MVP * vec4(vertex_pos, 1)).xyz);\n"
"  vec3 vertex_position_cameraspace = ( V * vec4(vertex_pos,1)).xyz;\n"
"  vec3 eye_direction_cameraspace = vec3(0,0,0) - vertex_position_cameraspace;\n"
"  vec3 light_position_cameraspace = ( V * vec4(light_posit,1)).xyz;\n"
"\n"
"  //WORLD OR CAMERA?\n"
"  vec3 light_direction_cameraspace;\n"
"  if(camera_anchored)\n"
"    light_direction_cameraspace = light_posit + eye_direction_cameraspace;\n"
"  else\n"
"    light_direction_cameraspace = light_position_cameraspace + eye_direction_cameraspace;\n"
"\n"
"  //vec3 normal_cameraspace = ( V * M * vec4(vertex_normal,0)).xyz;\n"
"  vec3 normal_cameraspace = normalize( cross( dFdx(vertex_position_cameraspace), dFdy(vertex_position_cameraspace) ) );\n"
"\n"
"  vec3 n = normalize( normal_cameraspace );\n"
"  vec3 l = normalize( light_direction_cameraspace );\n"
"  float cosTheta = clamp( dot( n,l ), 0.,1. );\n"
"\n"
"  vec3 E = normalize(eye_direction_cameraspace);\n"
"  vec3 R = reflect(-l,n);\n"
"  float cosAlpha = clamp( dot( E,R ), 0.,1. );\n"
"\n"
"  vec3 ambi_color = 0.1 *  mater_color;\n"
"  vec3 diff_color = mater_color;\n"
"  vec3 spec_color = 0.5 * (mater_color + vec3(1.0, 1.0, 1.0));\n"
"  vec3 color = mix_ratio.x * ambi_color\n"
"             + mix_ratio.y * diff_color * light_color * light_power * cosTheta        / (distance*distance)\n"
"             + mix_ratio.z * spec_color * light_color * light_power * pow(cosAlpha,lobe_size) / (distance*distance)\n"
"             ;\n"
"\n"
"  return color;\n"
"}\n"
"\n"
;


#endif  // #ifdef TXT_HEADER_flat_frag_code
